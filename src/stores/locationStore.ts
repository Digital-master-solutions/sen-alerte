import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { useEffect } from 'react';

// Types pour la g√©olocalisation
export interface Location {
  latitude: number;
  longitude: number;
  address?: string;
  city?: string;
  department?: string;
}

export interface LocationState {
  // Position actuelle de l'utilisateur
  currentLocation: Location | null;
  isLocationLoading: boolean;
  locationError: string | null;

  // Position par d√©faut du S√©n√©gal
  defaultLocation: Location;

  // Cache des adresses recherch√©es
  addressCache: Record<string, Location>;

  // Derni√®re position utilis√©e pour un signalement
  lastReportLocation: Location | null;

  // √âtat de la g√©olocalisation en temps r√©el
  isWatchingLocation: boolean;
  watchId: number | null;
  lastUpdateTime: number | null;

  // Actions
  setCurrentLocation: (location: Location | null) => void;
  setLocationLoading: (loading: boolean) => void;
  setLocationError: (error: string | null) => void;
  setLastReportLocation: (location: Location) => void;
  addToAddressCache: (query: string, location: Location) => void;
  getFromAddressCache: (query: string) => Location | null;
  requestLocation: () => Promise<Location | null>;
  reverseGeocode: (lat: number, lng: number) => Promise<Location | null>;
  startWatchingLocation: () => void;
  stopWatchingLocation: () => void;
  updateLocationFromWatch: (position: GeolocationPosition) => Promise<void>;
}

// Position par d√©faut du S√©n√©gal (Dakar)
const SENEGAL_DEFAULT_LOCATION: Location = {
  latitude: 14.4974,
  longitude: -14.4524,
  address: "Dakar, S√©n√©gal",
  city: "Dakar",
  department: "Dakar"
};

export const useLocationStore = create<LocationState>()(
  persist(
    immer((set, get) => ({
      // √âtat initial
      currentLocation: null,
      isLocationLoading: false,
      locationError: null,
      defaultLocation: SENEGAL_DEFAULT_LOCATION,
      addressCache: {},
      lastReportLocation: null,
      isWatchingLocation: false,
      watchId: null,
      lastUpdateTime: null,

      // Actions
      setCurrentLocation: (location) =>
        set((state) => {
          state.currentLocation = location;
          state.locationError = null;
        }),

      setLocationLoading: (loading) =>
        set((state) => {
          state.isLocationLoading = loading;
        }),

      setLocationError: (error) =>
        set((state) => {
          state.locationError = error;
          state.isLocationLoading = false;
        }),

      setLastReportLocation: (location) =>
        set((state) => {
          state.lastReportLocation = location;
        }),

      addToAddressCache: (query, location) =>
        set((state) => {
          state.addressCache[query.toLowerCase()] = location;
        }),

      getFromAddressCache: (query) => {
        const { addressCache } = get();
        return addressCache[query.toLowerCase()] || null;
      },

      // Demander la g√©olocalisation du navigateur avec haute pr√©cision
      requestLocation: async () => {
        const { setLocationLoading, setCurrentLocation, setLocationError } = get();
        
        setLocationLoading(true);
        setLocationError(null);

        try {
          if (!navigator.geolocation) {
            throw new Error('G√©olocalisation non support√©e par ce navigateur');
          }

          let bestPosition: GeolocationPosition | null = null;
          let bestAccuracy = Infinity;
          const maxAttempts = 3;
          const targetAccuracy = 20; // Pr√©cision cible de 20m maximum

          // Essayer plusieurs fois pour obtenir la meilleure pr√©cision
          for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
              console.log(`Tentative de g√©olocalisation ${attempt}/${maxAttempts}...`);
              
              const position = await new Promise<GeolocationPosition>((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                  resolve,
                  reject,
                  {
                    enableHighAccuracy: true,
                    timeout: attempt === 1 ? 15000 : 20000, // Plus de temps pour les tentatives suivantes
                    maximumAge: 0, // Position fra√Æche uniquement
                  }
                );
              });

              const accuracy = position.coords.accuracy;
              console.log(`Tentative ${attempt}: pr√©cision de ${accuracy.toFixed(1)}m`);

              // Garder la meilleure position
              if (accuracy < bestAccuracy) {
                bestPosition = position;
                bestAccuracy = accuracy;
              }

              // Si on a atteint la pr√©cision cible, on s'arr√™te
              if (accuracy <= targetAccuracy) {
                console.log(`‚úÖ Pr√©cision excellente atteinte: ${accuracy.toFixed(1)}m`);
                break;
              }

              // Attendre un peu avant la prochaine tentative
              if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 2000));
              }

            } catch (attemptError) {
              console.log(`Tentative ${attempt} √©chou√©e:`, attemptError);
              if (attempt === maxAttempts) {
                throw attemptError;
              }
            }
          }

          if (!bestPosition) {
            throw new Error('Impossible d\'obtenir une position GPS');
          }

          const finalAccuracy = bestPosition.coords.accuracy;
          console.log(`üéØ Meilleure pr√©cision obtenue: ${finalAccuracy.toFixed(1)}m`);

          const location: Location = {
            latitude: bestPosition.coords.latitude,
            longitude: bestPosition.coords.longitude,
          };

          // Essayer de r√©cup√©rer l'adresse
          const locationWithAddress = await get().reverseGeocode(
            location.latitude,
            location.longitude
          );

          const finalLocation = locationWithAddress || location;
          setCurrentLocation(finalLocation);
          return finalLocation;

        } catch (error) {
          const errorMessage = error instanceof Error 
            ? error.message 
            : 'Erreur lors de la g√©olocalisation';
          
          setLocationError(errorMessage);
          console.error('Erreur g√©olocalisation:', error);
          
          // Retourner la position par d√©faut du S√©n√©gal
          setCurrentLocation(SENEGAL_DEFAULT_LOCATION);
          return SENEGAL_DEFAULT_LOCATION;
        } finally {
          setLocationLoading(false);
        }
      },

      // G√©ocodage inverse (coordonn√©es -> adresse)
      reverseGeocode: async (lat, lng) => {
        try {
          // Utiliser Nominatim (OpenStreetMap) pour le g√©ocodage inverse
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=fr`
          );

          if (!response.ok) {
            throw new Error('Erreur g√©ocodage inverse');
          }

          const data = await response.json();

          const location: Location = {
            latitude: lat,
            longitude: lng,
            address: data.display_name || `${lat}, ${lng}`,
            city: data.address?.city || data.address?.town || data.address?.village || '',
            department: data.address?.state || data.address?.province || '',
          };

          return location;

        } catch (error) {
          console.error('Erreur g√©ocodage inverse:', error);
          return null;
        }
      },

      // D√©marrer la surveillance de la g√©olocalisation en temps r√©el
      startWatchingLocation: () => {
        const { isWatchingLocation, watchId } = get();
        
        if (isWatchingLocation || watchId !== null) {
          return; // D√©j√† en cours
        }

        if (!navigator.geolocation) {
          console.error('G√©olocalisation non support√©e');
          return;
        }

        const id = navigator.geolocation.watchPosition(
          (position) => {
            get().updateLocationFromWatch(position);
          },
          (error) => {
            console.error('Erreur surveillance g√©olocalisation:', error);
            get().setLocationError(`Erreur surveillance: ${error.message}`);
          },
          {
            enableHighAccuracy: true,
            timeout: 15000, // Plus de temps pour la haute pr√©cision
            maximumAge: 5000, // 5 secondes maximum
          }
        );

        set((state) => {
          state.isWatchingLocation = true;
          state.watchId = id;
        });

        console.log('Surveillance g√©olocalisation d√©marr√©e');
      },

      // Arr√™ter la surveillance de la g√©olocalisation
      stopWatchingLocation: () => {
        const { watchId } = get();
        
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
        }

        set((state) => {
          state.isWatchingLocation = false;
          state.watchId = null;
        });

        console.log('Surveillance g√©olocalisation arr√™t√©e');
      },

      // Mettre √† jour la localisation depuis la surveillance (en arri√®re-plan)
      updateLocationFromWatch: async (position) => {
        const { reverseGeocode, setCurrentLocation, currentLocation } = get();
        const now = Date.now();
        
        // √âviter les mises √† jour trop fr√©quentes (minimum 5 secondes)
        const { lastUpdateTime } = get();
        if (lastUpdateTime && (now - lastUpdateTime) < 5000) {
          return;
        }

        const accuracy = position.coords.accuracy;
        
        // Filtrer les positions selon leur pr√©cision (accepter seulement si pr√©cision <= 20m)
        if (accuracy > 20) {
          console.log(`Position rejet√©e: pr√©cision de ${accuracy.toFixed(1)}m (trop impr√©cise)`);
          return;
        }

        const newLocation: Location = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };

        // V√©rifier si la position a vraiment chang√© (√©viter les mises √† jour inutiles)
        if (currentLocation && 
            Math.abs(currentLocation.latitude - newLocation.latitude) < 0.00001 &&
            Math.abs(currentLocation.longitude - newLocation.longitude) < 0.00001) {
          return; // Position identique, pas de mise √† jour
        }

        try {
          // R√©cup√©rer l'adresse en arri√®re-plan (silencieux)
          const locationWithAddress = await reverseGeocode(
            newLocation.latitude,
            newLocation.longitude
          );

          const finalLocation = locationWithAddress || newLocation;
          
          // Mise √† jour silencieuse en arri√®re-plan
          setCurrentLocation(finalLocation);

          set((state) => {
            state.lastUpdateTime = now;
          });

          // Log discret pour le debug
          console.log('Position mise √† jour en arri√®re-plan:', {
            lat: finalLocation.latitude.toFixed(6),
            lng: finalLocation.longitude.toFixed(6),
            accuracy: `${accuracy.toFixed(1)}m`,
            address: finalLocation.address
          });
        } catch (error) {
          console.error('Erreur mise √† jour position:', error);
          // Mettre √† jour quand m√™me avec les coordonn√©es
          setCurrentLocation(newLocation);
          set((state) => {
            state.lastUpdateTime = now;
          });
        }
      },
    })),
    {
      name: 'location-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        currentLocation: state.currentLocation,
        addressCache: state.addressCache,
        lastReportLocation: state.lastReportLocation,
        lastUpdateTime: state.lastUpdateTime,
      }),
    }
  )
);

// Hook pour l'initialisation automatique de la g√©olocalisation
export const useLocationInit = () => {
  const requestLocation = useLocationStore((state) => state.requestLocation);
  const startWatchingLocation = useLocationStore((state) => state.startWatchingLocation);
  const stopWatchingLocation = useLocationStore((state) => state.stopWatchingLocation);

  useEffect(() => {
    // Initialisation unique au montage du composant
    const initializeLocation = async () => {
      try {
        // D√©marrer la surveillance en temps r√©el
        startWatchingLocation();
        
        // Demander une position initiale
        await requestLocation();
      } catch (error) {
        console.error('Erreur initialisation g√©olocalisation:', error);
      }
    };

    initializeLocation();

    // Cleanup: arr√™ter la surveillance quand le composant se d√©monte
    return () => {
      stopWatchingLocation();
    };
  }, []); // D√©pendances vides pour √©viter la boucle infinie
};